<!-- public/main/index.html -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <h1>Hello，Sandbox Script!</h1>

    <!-- 主应用导航 -->
    <div id="nav"></div>

    <!-- 主应用内容区 -->
    <div id="container"></div>

    <script type="text/javascript">
      class MicroAppSandbox {
        // 沙箱配置信息
        options = null;
        // 是否执行过 JS
        exec = false;
        // 微应用激活之前的主应用 window 快照
        mainWindow = {};
        // 微应用激活之后的 window 对象（用于理解）
        microWindow = {};
        // 微应用失活后和主应用的 window 快照存在差异的属性集合
        diffPropsMap = {};

        constructor(options) {
          this.options = options;
          // 重新包装需要执行的微应用 JS 脚本
          this.wrapScript = this.createWrapScript();
        }

        createWrapScript() {
          // 微应用的代码运行在立即执行的匿名函数中，隔离作用域
          return `;(function(){
            ${this.options.scriptText}
          })()`;
        }

        execWrapScript() {
          // 在全局作用域内执行微应用代码
          (0, eval)(this.wrapScript);
        }

        // 微应用激活之前需要记录主应用的 window 快照（用于微应用失活后的属性差异对比）
        recordMainWindow() {
          for (const prop in window) {
            if (window.hasOwnProperty(prop)) {
              this.mainWindow[prop] = window[prop];
            }
          }
        }

        // 微应用激活之前需要恢复微应用对应的 window 对象
        recoverMicroWindow() {
          // 如果微应用和主应用的 window 对象存在属性差异
          // 微应用 window = 主应用 window + 差异属性（在微应用失活后会记录运行过程中涉及到更改的 window 属性值，再次激活时需要恢复之前修改的属性值）
          Object.keys(this.diffPropsMap).forEach((p) => {
            // 更改激活之前的微应用 window 对象，注意微应用本质上是共享主应用的 window 对象的，因此一个时刻只能运行一个微应用
            window[p] = this.diffPropsMap[p];
          });
          // 用于课程理解
          this.microWindow = window;
        }

        recordDiffPropsMap() {
          // 这里的 microWindow 是微应用失活之后的 window（在微应用执行期间修改过 window 属性的 window）
          for (const prop in this.microWindow) {
            // 如果微应用运行期间存在和主应用不一样的属性值
            if (
              window.hasOwnProperty(prop) &&
              this.microWindow[prop] !== this.mainWindow[prop]
            ) {
              // 记录微应用运行期间修改过的差异属性（下一次激活微应用时可用于恢复微应用的 window 属性）
              this.diffPropsMap[prop] = this.microWindow[prop];
              // 恢复主应用的 window 属性值
              window[prop] = this.mainWindow[prop];
            }
          }
        }

        active() {
          // 记录微应用执行之前的主应用 window 快照
          this.recordMainWindow();
          // 恢复微应用需要的 window 对象
          this.recoverMicroWindow();
          if (this.exec) {
            return;
          }
          this.exec = true;
          // 执行微应用
          this.execWrapScript();
        }

        inactive() {
          // 清空上一次记录的属性差异
          this.diffPropsMap = {};
          // 记录微应用运行后和主应用 Window 快照存在的差异属性
          this.recordDiffPropsMap();
          console.log(
            `${this.options.appId} diffPropsMap: `,
            this.diffPropsMap
          );
        }

        destroy() {}
      }

      // 微应用管理
      class MicroApp {
        // 缓存微应用的脚本文本（这里假设只有一个执行脚本）
        scriptText = "";
        // 隔离实例
        sandbox = null;
        // 微应用挂载的根节点
        rootElm = null;

        constructor(rootElm, app) {
          this.rootElm = rootElm;
          this.app = app;
        }

        // 获取 JS 文本（微应用服务需要支持跨域请求获取 JS 文件）
        async fetchScript(src) {
          try {
            const res = await window.fetch(src);
            return await res.text();
          } catch (err) {
            console.error(err);
          }
        }

        // 激活
        async active() {
          // 缓存资源处理
          if (!this.scriptText) {
            this.scriptText = await this.fetchScript(this.app.script);
          }

          // 如果没有创建沙箱，则实时创建
          if (!this.sandbox) {
            this.sandbox = new MicroAppSandbox({
              scriptText: this.scriptText,
              appId: this.app.id,
            });
          }

          this.sandbox.active();

          // 获取元素并进行展示，这里先临时约定微应用往 body 下新增 id 为 `${this.app.id}-dom` 的元素
          const microElm = document.getElementById(`${this.app.id}-dom`);
          if (microElm) {
            microElm.style = "display: block";
          }
        }

        // 失活
        inactive() {
          const microElm = document.getElementById(`${this.app.id}-dom`);
          if (microElm) {
            microElm.style = "display: none";
          }
          this.sandbox?.inactive();
        }
      }

      // 微前端管理
      class MicroApps {
        // 微应用实例映射表
        appsMap = new Map();
        // 微应用挂载的根节点信息
        rootElm = null;

        constructor(rootElm, apps) {
          this.rootElm = rootElm;
          this.setAppMaps(apps);
        }

        setAppMaps(apps) {
          apps.forEach((app) => {
            this.appsMap.set(app.id, new MicroApp(this.rootElm, app));
          });
        }

        // TODO: prefetch 微应用
        prefetchApps() {}

        // 激活微应用
        activeApp(id) {
          const app = this.appsMap.get(id);
          app?.active();
        }

        // 失活微应用
        inactiveApp(id) {
          const app = this.appsMap.get(id);
          app?.inactive();
        }
      }

      // 主应用管理
      class MainApp {
        microApps = [];
        microAppsManager = null;

        constructor() {
          this.init();
        }

        async init() {
          this.microApps = await this.fetchMicroApps();
          this.createNav();
          this.navClickListener();
          this.hashChangeListener();
          // 创建微前端管理实例
          this.microAppsManager = new MicroApps(
            document.getElementById("container"),
            this.microApps
          );
        }

        // 从主应用服务器获请求微应用列表信息
        async fetchMicroApps() {
          try {
            const res = await window.fetch("/microapps", {
              method: "post",
            });
            return await res.json();
          } catch (err) {
            console.error(err);
          }
        }

        // 根据微应用列表创建主导航
        createNav(microApps) {
          const fragment = new DocumentFragment();
          this.microApps?.forEach((microApp) => {
            // TODO: APP 数据规范检测 (例如是否有 script）
            const button = document.createElement("button");
            button.textContent = microApp.name;
            button.id = microApp.id;
            fragment.appendChild(button);
          });
          nav.appendChild(fragment);
        }

        // 导航点击的监听事件
        navClickListener() {
          const nav = document.getElementById("nav");
          nav.addEventListener("click", (e) => {
            console.log("主应用 window.a: ", window.a);
            // 并不是只有 button 可以触发导航变更，例如 a 标签也可以，因此这里不直接处理微应用切换，只是改变 Hash 地址
            // 不会触发刷新，类似于框架的 Hash 路由
            window.location.hash = event?.target?.id;
          });
        }

        // hash 路由变化的监听事件
        hashChangeListener() {
          // 监听 Hash 路由的变化，切换微应用（这里设定一个时刻只能切换一个微应用）
          window.addEventListener("hashchange", () => {

            // 由于一个时刻只能激活一个应用，因此需要先失活已经激活的应用，才能进行其他应用的激活处理
            this.microApps?.forEach(async ({ id }) => {
              if (id !== window.location.hash.replace("#", "")) {
                this.microAppsManager.inactiveApp(id);
              }
            });
            // 激活应用
            this.microApps?.forEach(async ({ id }) => {
              if (id === window.location.hash.replace("#", "")) {
                this.microAppsManager.activeApp(id);
              }
            });

          });
        }
      }

      new MainApp();
    </script>
  </body>
</html>
