<!-- public/main/index.html -->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Main App Document</title>
  </head>

  <body>
    <h1>Hello，Sandbox Script!</h1>

    <!-- 主应用导航 -->
    <div id="nav"></div>

    <!-- 主应用内容区 -->
    <div id="container"></div>

    <script type="text/javascript">
      // 隔离类
      class IframeSandbox {
        // 沙箱配置信息
        options = null;
        // iframe 实例
        iframe = null;
        // iframe 的 Window 实例
        iframeWindow = null;
        // 是否执行过 JS
        execScriptFlag = false;

        constructor(options) {
          this.options = options;
          // 创建 iframe 时浏览器会创建新的全局执行上下文，用于隔离主应用的全局执行上下文
          this.iframe = this.createIframe();
          this.iframeWindow = this.iframe.contentWindow;
          this.proxyIframeWindow();
        }

        createIframe() {
          const { rootElm, id, url } = this.options;
          const iframe = window.document.createElement("iframe");
          const attrs = {
            src: "about:blank",
            "app-id": id,
            "app-src": url,
            style: "border:none;width:100%;height:100%;",
          };
          Object.keys(attrs).forEach((name) => {
            iframe.setAttribute(name, attrs[name]);
          });
          rootElm?.appendChild(iframe);
          return iframe;
        }

        isBoundedFunction(fn) {
          return (
            // 被绑定的函数本身没有 prototype
            fn.name.indexOf("bound ") === 0 && !fn.hasOwnProperty("prototype")
          );
        }

        isConstructable(fn) {
          // 可以识别 Object、Array 等原生构造函数，也可以识别用户自己创建的构造函数
          return (
            fn.prototype &&
            // 通常情况下构造函数和类的 prototype.constructor 指向本身
            fn.prototype.constructor === fn &&
            // 通常情况下构造函数和类都会存在 prototype.constructor，因此长度至少大于 1
            // 需要注意普通函数中也会存在 prototype.constructor，
            // 因此如果 prototype 有自定义属性或者方法，那么可以判定为类或者构造函数，因此这里的判断是大于 1
            // 注意不要使用 Object.keys 进行判断，Object.keys 无法获取 Object.defineProperty 定义的属性
            Object.getOwnPropertyNames(fn.prototype).length > 1
          );
          // TODO: 没有 constructor 的构造函数识别、class 识别、function Person() {} 识别等
          // 例如 function Person {};  Person.prototype = {}; 此时没有 prototype.constructor 属性
        }

        // 修复 window.alert、window.addEventListener 等报错 Illegal invocation 的问题
        // window.alert 内部的 this 不是指向 iframe 的 window，而是指向被代理后的 proxy，因此在调用 alert 等原生函数会报错 Illegal invocation
        // 因此这里需要重新将这些原生 native api 的 this 修正为 iframe 的 window
        getTargetValue(target, prop) {
          const value = target[prop];

          // 过滤出 window.alert、window.addEventListener 等 API
          if (
            typeof value === "function" &&
            !this.isBoundedFunction(value) &&
            !this.isConstructable(value)
          ) {
            console.log("修正 this: ", prop);

            // 修正 value 的 this 指向为 target
            const boundValue = Function.prototype.bind.call(value, target);
            // 重新恢复 value 在 bound 之前的属性和原型（bind 之后会丢失）
            for (const key in value) {
              boundValue[key] = value[key];
            }
            // 如果原来的函数存在 prototype 属性，而 bound 之后丢失了，那么重新设置回来
            if (
              value.hasOwnProperty("prototype") &&
              !boundValue.hasOwnProperty("prototype")
            ) {
              boundValue.prototype = value.prototye;
            }
            return boundValue;
          }
          return value;
        }

        proxyIframeWindow() {
          this.iframeWindow.proxy = new Proxy(this.iframeWindow, {
            get: (target, prop) => {
              // console.log("get target prop: ", prop);

              // TODO: 这里只是课程演示，主要用于解决 src:about:blank 下的 history 同域问题，并没有真正设计主子应用的路由冲突问题，后续的课程会进行该设计
              // 思考：为了防止 URL 冲突问题，是否也可以形成设计规范，比如主应用采用 History 路由，子应用采用 Hash 路由，从而确保主子应用的路由不会产生冲突的问题
              if (prop === "history" || prop === "location") {
                return window[prop];
              }

              if (prop === "window" || prop === "self") {
                return this.iframeWindow.proxy;
              }

              return this.getTargetValue(target, prop);
            },

            set: (target, prop, value) => {
              target[prop] = value;
              return true;
            },

            has: (target, prop) => true,
          });
        }

        execScript() {
          const scriptElement =
            this.iframeWindow.document.createElement("script");
          scriptElement.textContent = `
              (function(window) {
                with(window) {
                  ${this.options.scriptText}
                }
              }).bind(window.proxy)(window.proxy);
              `;
          this.iframeWindow.document.head.appendChild(scriptElement);
        }

        // 激活
        async active() {
          this.iframe.style.display = "block";
          // 如果已经通过 Script 加载并执行过 JS，则无需重新加载处理
          if (this.execScriptFlag) return;
          this.execScript();
          this.execScriptFlag = true;
        }

        // 预渲染
        prerender() {
          this.iframe.style.display = "none";
          // 如果已经通过 Script 加载并执行过 JS，则无需重新加载处理
          if (this.execScriptFlag) return;
          this.execScript();
          this.execScriptFlag = true;
        }

        // 失活
        // INFO: JS 加载以后无法通过移除 Script 标签去除执行状态
        // INFO: 因此这里不是指代失活 JS，如果是真正想要失活 JS，需要销毁 iframe 后重新加载 Script
        inactive() {
          this.iframe.style.display = "none";
        }

        // 销毁沙箱
        destroy() {
          this.options = null;
          this.exec = false;
          if (this.iframe) {
            this.iframe.parentNode?.removeChild(this.iframe);
          }
          this.iframe = null;
        }
      }

      // 微应用管理
      class MicroAppManager {
        // 缓存微应用的脚本文本（这里假设只有一个执行脚本）
        scriptText = "";
        // 隔离实例
        sandbox = null;
        // 微应用挂载的根节点
        rootElm = null;

        constructor(rootElm, app) {
          this.rootElm = rootElm;
          this.app = app;
        }

        // 获取 JS 文本（微应用服务需要支持跨域请求）
        async fetchScript() {
          try {
            const res = await window.fetch(this.app.script);
            return await res.text();
          } catch (err) {
            console.error(err);
          }
        }

        // 预渲染
        rerender() {
          // 当前主线程中存在多个并行执行的 requestIdleCallback 时，浏览器会根据空闲时间来决定要在当前 Frame 还是下一个 Frame 执行
          requestIdleCallback(async () => {
            // 预请求资源
            this.scriptText = await this.fetchScript();
            // 预渲染处理
            this.idlePrerender();
          });
        }

        idlePrerender() {
          // 预渲染
          requestIdleCallback((dealline) => {
            console.log("deadline: ", dealline.timeRemaining());
            // 这里只有在浏览器非常空闲时才可以进行操作
            if (dealline.timeRemaining() > 40) {
              // TODO: active 中还可以根据 Performance 性能面板进行再分析，如果内部的某些操作比较耗时，可能会影响下一帧的渲染，则可以放入新的 requestIdleCallback 中进行处理
              // 除此之外，例如在子应用中可以先生成虚拟 DOM 树，预渲染不做 DOM 更改处理，真正切换应用的时候进行 DOM 挂载
              // 也可以在挂载应用的时候放入 raF 中进行处理
              this.active(true);
            } else {
              this.idlePrerender();
            }
          });
        }

        // 激活
        async active(isPrerender) {
          // 缓存资源处理
          if (!this.scriptText) {
            this.scriptText = await this.fetchScript();
          }

          // 如果没有创建沙箱，则实时创建
          // 需要注意只给激活的微应用创建 iframe 沙箱，因为创建 iframe 会产生内存损耗
          if (!this.sandbox) {
            this.sandbox = new IframeSandbox({
              rootElm: this.rootElm,
              scriptText: this.scriptText,
              url: this.app.script,
              id: this.app.id,
            });
          }

          isPrerender ? this.sandbox.prerender() : this.sandbox.active();
        }

        // 失活
        inactive() {
          this.sandbox?.inactive();
        }
      }

      // 微前端管理
      class MicroManager {
        // 微应用实例映射表
        appsMap = new Map();
        // 微应用挂载的根节点信息
        rootElm = null;

        constructor(rootElm, apps) {
          this.rootElm = rootElm;
          // this.setAppMaps(apps);
          this.initApps(apps);
        }

        initApps(apps) {
          apps.forEach((app) => {
            const appManager = new MicroAppManager(this.rootElm, app);
            this.appsMap.set(app.id, appManager);
            if (app.prerender) {
              appManager.rerender();
            }
          });
        }

        // 激活微应用
        activeApp(id) {
          const current = this.appsMap.get(id);
          current && current.active();
        }

        // 失活微应用
        inactiveApp(id) {
          const current = this.appsMap.get(id);
          current && current.inactive();
        }
      }

      // 主应用管理
      class MainApp {
        microApps = [];
        microManager = null;

        constructor() {
          this.init();
        }

        async init() {
          this.microApps = await this.fetchMicroApps();
          this.createNav();
          this.navClickListener();
          this.hashChangeListener();
          // 创建微前端管理实例
          this.microManager = new MicroManager(
            document.getElementById("container"),
            this.microApps
          );
        }

        // 从主应用服务器获请求微应用列表信息
        async fetchMicroApps() {
          try {
            const res = await window.fetch("/microapps", {
              method: "post",
            });
            return await res.json();
          } catch (err) {
            console.error(err);
          }
        }

        // 根据微应用列表创建主导航
        createNav(microApps) {
          const fragment = new DocumentFragment();
          this.microApps?.forEach((microApp) => {
            // TODO: APP 数据规范检测 (例如是否有 script）
            const button = document.createElement("button");
            button.textContent = microApp.name;
            button.id = microApp.id;
            fragment.appendChild(button);
          });
          nav.appendChild(fragment);
        }

        // 导航点击的监听事件
        navClickListener() {
          const nav = document.getElementById("nav");
          nav.addEventListener("click", (e) => {
            // 并不是只有 button 可以触发导航变更，例如 a 标签也可以，因此这里不直接处理微应用切换，只是改变 Hash 地址
            // 不会触发刷新，类似于框架的 Hash 路由
            window.location.hash = event?.target?.id;
          });
        }

        // hash 路由变化的监听事件
        hashChangeListener() {
          // 监听 Hash 路由的变化，切换微应用（这里设定一个时刻只能切换一个微应用）
          window.addEventListener("hashchange", () => {
            this.microApps?.forEach(async ({ id }) => {
              id === window.location.hash.replace("#", "")
                ? this.microManager.activeApp(id)
                : this.microManager.inactiveApp(id);
            });
          });
        }
      }

      new MainApp();
    </script>
  </body>
</html>
